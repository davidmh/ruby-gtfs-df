#!/usr/bin/env bash
set -e

# Script to bump gem version, generate changelog, and create a PR

VERSION_FILE="lib/gtfs_df/version.rb"
CHANGELOG_FILE="CHANGELOG.md"

DRY_RUN=false

validate_bump_type() {
    local bump_type="$1"
    case "$bump_type" in
        major|minor|patch)
            return 0
            ;;
        *)
            echo "‚ùå Error: Invalid bump type '$bump_type'"
            echo "Valid types: major, minor, patch"
            exit 1
            ;;
    esac
}

check_clean_working_tree() {
    local status
    status=$(git status --porcelain)
    if [[ -n "$status" ]]; then
        echo "‚ùå Error: Working tree is not clean. Please commit or stash changes first."
        echo "$status"
        exit 1
    fi
}

read_current_version() {
    if [[ ! -f "$VERSION_FILE" ]]; then
        echo "‚ùå Error: Version file not found: $VERSION_FILE"
        exit 1
    fi

    local version
    version=$(grep -oE 'VERSION = "[0-9]+\.[0-9]+\.[0-9]+"' "$VERSION_FILE" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+')

    if [[ -z "$version" ]]; then
        echo "‚ùå Error: Could not parse current version from $VERSION_FILE"
        exit 1
    fi

    echo "$version"
}

calculate_new_version() {
    local current_version="$1"
    local bump_type="$2"

    IFS='.' read -r major minor patch <<< "$current_version"

    case "$bump_type" in
        major)
            echo "$((major + 1)).0.0"
            ;;
        minor)
            echo "${major}.$((minor + 1)).0"
            ;;
        patch)
            echo "${major}.${minor}.$((patch + 1))"
            ;;
    esac
}

create_branch() {
    local branch_name="$1"
    echo ""
    echo "üåø Creating branch: $branch_name"
    git checkout -b "$branch_name"
}

update_version_file() {
    local old_version="$1"
    local new_version="$2"

    echo ""
    echo "üìù Updating $VERSION_FILE"

    sed -i "s/VERSION = \"$old_version\"/VERSION = \"$new_version\"/" "$VERSION_FILE"
}

update_lock_file() {
  echo ""
  echo "üîì Updating lock file"

  bundle install
}

generate_changelog_entry() {
    local version="$1"
    local last_tag
    local commits
    local today

    echo "üìã Generating changelog entry..." >&2

    today=$(date +%Y-%m-%d)
    last_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

    if [[ -z "$last_tag" ]]; then
        echo "‚ö†Ô∏è  No previous tag found, getting all commits" >&2
        commits=$(git log --pretty=format:"%s" --reverse)
    else
        echo "üìå Getting commits since $last_tag" >&2
        commits=$(git log "$last_tag..HEAD" --pretty=format:"%s" --reverse)
    fi

    # Arrays for categorizing commits
    local -a features=()
    local -a fixes=()
    local -a chores=()

    while IFS= read -r commit; do
        [[ -z "$commit" ]] && continue
        [[ "$commit" =~ ^Merge\ (pull\ request|branch) ]] && continue

        if [[ "$commit" =~ ^[Ff]eat(\(.+\))?:[[:space:]]* ]]; then
            features+=("${commit#*: }")
        elif [[ "$commit" =~ ^[Ff]ix(\(.+\))?:[[:space:]]* ]]; then
            fixes+=("${commit#*: }")
        elif [[ "$commit" =~ ^[Cc]hore(\(.+\))?:[[:space:]]* ]]; then
            chores+=("${commit#*: }")
        fi
    done <<< "$commits"

    # Build changelog entry
    local entry="## [$version] - $today"$'\n'

    if [[ ${#features[@]} -gt 0 ]]; then
        entry+=$'\n'"### Added"$'\n'$'\n'
        for feat in "${features[@]}"; do
            entry+="- $feat"$'\n'
        done
        entry+=$'\n'
    fi

    if [[ ${#fixes[@]} -gt 0 ]]; then
        entry+="### Fixed"$'\n'$'\n'
        for fix in "${fixes[@]}"; do
            entry+="- $fix"$'\n'
        done
        entry+=$'\n'
    fi

    if [[ ${#chores[@]} -gt 0 ]]; then
        entry+="### Maintenance"$'\n'$'\n'
        for chore in "${chores[@]}"; do
            entry+="- $chore"$'\n'
        done
        entry+=$'\n'
    fi

    echo "$entry"
}

update_changelog() {
    local changelog_entry="$1"

    echo ""
    echo "üìù Updating $CHANGELOG_FILE"

    if [[ -f "$CHANGELOG_FILE" ]]; then
        local current_content
        current_content=$(cat "$CHANGELOG_FILE")

        if grep -q '^## \[' "$CHANGELOG_FILE"; then
            # Already has version entries - insert new entry before first version entry
            awk -v entry="$changelog_entry" '
                !inserted && /^## \[/ { 
                    print entry
                    inserted=1 
                }
                { print }
            ' "$CHANGELOG_FILE" > "${CHANGELOG_FILE}.tmp"
            mv "${CHANGELOG_FILE}.tmp" "$CHANGELOG_FILE"
        else
            # First version entry
            echo "$changelog_entry" > "${CHANGELOG_FILE}.tmp"
            cat "$CHANGELOG_FILE" >> "${CHANGELOG_FILE}.tmp"
            mv "${CHANGELOG_FILE}.tmp" "$CHANGELOG_FILE"
        fi
    else
        echo "# Changelog" > "$CHANGELOG_FILE"
        echo "" >> "$CHANGELOG_FILE"
        echo "$changelog_entry" >> "$CHANGELOG_FILE"
    fi
}

commit_changes() {
    local version="$1"
    echo ""
    echo "üíæ Committing changes..."
    git add "$VERSION_FILE" "$CHANGELOG_FILE" Gemfile.lock
    git commit -m "chore: bump version to $version"
}

push_branch() {
    local branch_name="$1"
    echo ""
    if [[ "$DRY_RUN" == true ]]; then
      echo "‚è∏Ô∏è [dry run] Not pushing branch..."
    else
      echo "‚¨ÜÔ∏è  Pushing branch to remote..."
      git push -u origin "$branch_name"
    fi
}

create_pull_request() {
    local version="$1"
    local changelog_entry="$2"
    local branch_name="$3"

    echo ""
    echo "üîÄ Creating pull request..."

    # Extract just the changes (skip first 2 lines: header and empty line)
    local pr_body
    pr_body=$(echo "$changelog_entry" | tail -n +3 | sed '/^$/d')

    if [[ -z "$pr_body" ]]; then
        pr_body="This PR bumps the version to $version."
    fi

    local title="Release v$version"

    gh pr create --title "$title" --body "$pr_body" --base main --head "$branch_name"
}

show_usage() {
    echo "Usage: $0 [major|minor|patch] [--dry-run]"
    echo ""
    echo "Examples:"
    echo "  $0 patch           # 0.1.1 -> 0.1.2"
    echo "  $0 minor           # 0.1.1 -> 0.2.0"
    echo "  $0 major           # 0.1.1 -> 1.0.0"
    echo "  $0 patch --dry-run # Preview changes without creating PR"
    exit 1
}

main() {
    if [[ $# -eq 0 ]]; then
        show_usage
    fi

    local bump_type="$1"

    if [[ "$*" == *"--dry-run"* ]]; then
        DRY_RUN=true
    fi

    validate_bump_type "$bump_type"

    echo "üöÄ Starting version bump process..."
    check_clean_working_tree

    local current_version
    current_version=$(read_current_version)

    local new_version
    new_version=$(calculate_new_version "$current_version" "$bump_type")

    echo ""
    echo "üìä Version: $current_version ‚Üí $new_version"
    echo "Bump type: $bump_type"

    echo ""
    read -rp "Proceed? (y/n): " response
    if [[ ! "$response" =~ ^[Yy]$ ]]; then
        echo "Aborted."
        exit 0
    fi

    local branch_name="release/v$new_version"

    create_branch "$branch_name"
    update_version_file "$current_version" "$new_version"

    update_lock_file

    local changelog_entry
    changelog_entry=$(generate_changelog_entry "$new_version")
    update_changelog "$changelog_entry"

    commit_changes "$new_version"
    push_branch "$branch_name"

    if [[ "$DRY_RUN" == true ]]; then
        echo ""
        echo "üîç [dry run] Skipping pull request creation"
        echo ""
        echo "‚úÖ Done! Changes committed to branch $branch_name"
    else
        create_pull_request "$new_version" "$changelog_entry" "$branch_name"
        echo ""
        echo "‚úÖ Done! Pull request created for version $new_version"
    fi
}

main "$@"
